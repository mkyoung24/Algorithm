# 문자열 검색
- 어떤 문자열 안에 특정 문자열이 들어 있는지 조사하고, 들어 있다면 그 위치를 찾는 것


## 브루트-포스
![브루트-포스법](https://github.com/mkyoung24/Algorithm/assets/103173521/0410184c-5886-4873-b28a-990f314fac74)
- 텍스트 "ABABCDEFGHA"에서 패턴 "ABC"를 브루트-포스법(brute force method)을 사용해 검색하는 과정
1. 텍스트의 첫 문자 'A'부터 시작하는 3개의 문자와 "ABC"가 일치하는지 검사함
2. 패턴을 1칸 뒤로 옮김
3. 패턴을 다시 1칸 뒤로 옮김


### String.indexOf 메소드로 문자열 검색하기
- java.lang.String 클래스는 문자열을 검색하는 indexOf 메서드와 lastIndexOf 메서드를 제공함
```
  1)int indexOf(String str)
  2)int indexOf(String str, int fromlndex)
  3)int lastIndexOf(String str)
  4)int lastIndexOf(String str, int fromIndex)
```


## KMP법
![kmp법](https://github.com/mkyoung24/Algorithm/assets/103173521/d9de9134-d431-44eb-976c-afb3af8af9c4)
- 일치하지 않는 문자를 만나면 패턴을 1칸 옮긴 다음, 패턴의 처음부터 다시 검사하는 브루트-포스법과는 달리 그때까지 검사한 결과를 효과적으로 이용하는 알고리즘
- 텍스트와 패턴 사이에 겹치는 부분을 찾아내 검사를 다시 시작할 위치를 구하여 패턴을 한번에 많이 옮기는 알고리즘


## 보이어-무어법
![보이어무어법](https://github.com/mkyoung24/Algorithm/assets/103173521/a5a02259-ddee-41c7-acbd-2abcf01021d6)
- 브루트-포스법을 개선한 KMP법보다 효율이 더 좋기 때문에 실제 문자열 검색 프로그램에서 널리 사용하는 알고리즘
- 패턴의 마지막 문자부터 앞쪽으로 검사를 진행하면서 일치하지 않는 문자가 있으면 미리 준비한 표에 따라 옮길 크기를 정함


#### 시간 복잡도와 실용성
텍스트의 문자 수 : n, 패턴의 문자 : m
* 브루트-포스법
  * 이 알고리즘의 시간 복잡도는 O(mn)이지만, 일부러 만든 패턴이 아닌 한 실질적인 시간 복잡도는 O(n)이 되는 것으로 알려져 있음
  * 단순한 알고리즘이지만 의외로 속도가 빠름
* KMP
  * 이 알고리즘의 시간 복잡도는 최악의 경우에도 O(n)으로 매우 빠름
  * KMP법은 검색하는 과정에서 선택한 요소를 다시 앞쪽으로 되돌릴 필요가 없으므로 파일에서 순서대로 읽어 들이면서 검색하는 경우에 알맞음
  * 처리하기 복잡하고 패턴 안에 반복하는 요소가 없으면 효율이 떨어진다는 단점
* 보이어-무어법
  * 이 알고리즘의 시간 복잡도는 최악의 경우에도 O(n), 평균적으로 O(n/m)으로 매우 빠름
  * 원래 알고리즘인 2개의 배열을 사용하는 방법은 배열을 작성할 때 KMP법과 마찬가지로 처리하기 복잡하므로 효과가 상쇄됨
  * 간략한 보이어-무어법을 사용해도 충분히 빠르게 검색할 수 있음
 

`실제 프로그램을 작설할 대는 기본적으로 표준 라이브러리인 String.indexOf 메서드를 사용`

   
